<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plagiarism Detector</title>
    <style>
        :root {
            --primary: #4f46e5;
            --primary-light: #818cf8;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --background: #f9fafb;
            --text: #1f2937;
            --text-light: #6b7280;
            --border: #d1d5db;
        }
       
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
       
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: var(--text);
            background-color: var(--background);
            padding: 2rem;
        }
       
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
       
        header {
            text-align: center;
            margin-bottom: 2rem;
        }
       
        h1 {
            font-size: 2.5rem;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
       
        h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--text);
        }
       
        h3 {
            font-size: 1.25rem;
            margin-bottom: 0.75rem;
            color: var(--text);
        }
       
        p {
            margin-bottom: 1rem;
        }
       
        .tabs {
            display: flex;
            margin-bottom: 2rem;
            border-bottom: 1px solid var(--border);
        }
       
        .tab-button {
            padding: 0.75rem 1.5rem;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-light);
            transition: all 0.2s;
        }
       
        .tab-button:hover {
            color: var(--primary);
        }
       
        .tab-button.active {
            color: var(--primary);
            border-bottom: 2px solid var(--primary);
        }
       
        .tab-content {
            display: none;
        }
       
        .tab-content.active {
            display: block;
        }
       
        .upload-area {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
        }
       
        .upload-box {
            flex: 1;
            border: 2px dashed var(--border);
            border-radius: 0.5rem;
            padding: 2rem;
            text-align: center;
            transition: all 0.2s;
        }
       
        .upload-box.active {
            border-color: var(--primary);
        }
       
        .upload-box h3 {
            margin-bottom: 1rem;
        }
       
        .file-input {
            display: none;
        }
       
        .btn {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 500;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid transparent;
        }
       
        .btn-primary {
            background-color: var(--primary);
            color: white;
        }
       
        .btn-primary:hover {
            background-color: var(--primary-light);
        }
       
        .btn-primary:disabled {
            background-color: var(--border);
            cursor: not-allowed;
        }
       
        .btn-outline {
            background-color: transparent;
            border-color: var(--primary);
            color: var(--primary);
        }
       
        .btn-outline:hover {
            background-color: var(--primary);
            color: white;
        }
       
        .btn-outline:disabled {
            border-color: var(--border);
            color: var(--text-light);
            cursor: not-allowed;
        }
       
        .action-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 1rem;
        }
       
        .settings-panel {
            margin-bottom: 2rem;
            padding: 1.5rem;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
        }
       
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            cursor: pointer;
        }
       
        .settings-content {
            display: none;
        }
       
        .settings-group {
            margin-bottom: 1.5rem;
        }
       
        .settings-group:last-child {
            margin-bottom: 0;
        }
       
        .settings-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
       
        .settings-select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            font-size: 1rem;
        }
       
        #result-section {
            display: none;
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border);
        }
       
        .similarity-result {
            display: flex;
            align-items: center;
            gap: 2rem;
            margin-bottom: 1.5rem;
        }
       
        .similarity-gauge {
            width: 150px;
            height: 75px;
            flex-shrink: 0;
        }
       
        .gauge {
            width: 100%;
            height: 100%;
        }
       
        .alert {
            flex: 1;
            padding: 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
        }
       
        .alert-success {
            background-color: rgba(16, 185, 129, 0.1);
            color: var(--success);
        }
       
        .alert-warning {
            background-color: rgba(245, 158, 11, 0.1);
            color: var(--warning);
        }
       
        .alert-danger {
            background-color: rgba(239, 68, 68, 0.1);
            color: var(--danger);
        }
       
        .badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 500;
        }
       
        .badge-success {
            background-color: rgba(16, 185, 129, 0.1);
            color: var(--success);
        }
       
        .badge-warning {
            background-color: rgba(245, 158, 11, 0.1);
            color: var(--warning);
        }
       
        .badge-danger {
            background-color: rgba(239, 68, 68, 0.1);
            color: var(--danger);
        }
       
        .loader {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s infinite linear;
            margin-right: 0.5rem;
        }
       
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
       
        /* Google Classroom specific styles */
        #classroom-login {
            text-align: center;
            margin: 2rem 0;
        }
       
        #classroom-selection {
            display: none;
        }
       
        #assignment-section {
            display: none;
        }
       
        .course-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
       
        .course-card {
            padding: 1.5rem;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }
       
        .course-card:hover {
            border-color: var(--primary-light);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
       
        .course-card.selected {
            border-color: var(--primary);
            background-color: rgba(79, 70, 229, 0.05);
        }
       
        .course-name {
            font-weight: 500;
            margin-bottom: 0.5rem;
        }
       
        .course-details {
            font-size: 0.875rem;
            color: var(--text-light);
        }
       
        .assignment-item {
            margin-bottom: 1.5rem;
            padding: 1.5rem;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
        }
       
        .assignment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
       
        .assignment-title {
            font-weight: 500;
            font-size: 1.25rem;
        }
       
        .assignment-due {
            font-size: 0.875rem;
            color: var(--text-light);
        }
       
        .assignment-meta {
            display: flex;
            gap: 0.75rem;
            margin-top: 0.75rem;
        }
       
        .assignment-submissions {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }
       
        .batch-action {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
       
        .submission-list {
            list-style: none;
        }
       
        .submission-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid var(--border);
        }
       
        .submission-item:last-child {
            border-bottom: none;
        }
       
        .student-name {
            font-weight: 500;
        }
       
        .user-profile {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border);
        }
       
        .user-avatar {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            overflow: hidden;
        }
       
        .user-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
       
        .user-name {
            font-weight: 500;
        }
       
        .user-email {
            font-size: 0.875rem;
            color: var(--text-light);
        }
       
        /* Report styles */
        #report-section {
            display: none;
        }
       
        .report-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 2rem;
        }
       
        .report-info {
            flex: 1;
        }
       
        .report-title {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
        }
       
        .report-metadata {
            font-size: 0.875rem;
            color: var(--text-light);
        }
       
        /* Matrix styles removed as requested */
       
        .modal-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
       
        .modal-content {
            width: 90%;
            max-width: 1000px;
            max-height: 90vh;
            background-color: white;
            border-radius: 0.5rem;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
       
        .modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
       
        .modal-body {
            padding: 1.5rem;
            flex: 1;
            overflow-y: auto;
        }
       
        .modal-footer {
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
        }
       
        .close-modal {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-light);
        }
       
        .comparison-container {
            display: flex;
            gap: 1.5rem;
        }
       
        .comparison-side {
            flex: 1;
            min-width: 0;
        }
       
        .comparison-content {
            padding: 1rem;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            margin-top: 0.75rem;
        }
       
        .highlight {
            background-color: rgba(245, 158, 11, 0.2);
            padding: 0.125rem 0;
        }
       
        /* Document comparison view styles */
        .document-comparison {
            display: flex;
            gap: 1.5rem;
            margin-top: 2rem;
            margin-bottom: 2rem;
        }
       
        .document-side {
            flex: 1;
            min-width: 300px;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1rem;
            background-color: white;
        }
       
        .document-content {
            font-size: 0.9rem;
            line-height: 1.5;
            white-space: pre-wrap;
        }
       
        .highlight {
            padding: 2px 0;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s;
        }
       
        .highlight-success {
            background-color: rgba(16, 185, 129, 0.2);
        }
       
        .highlight-warning {
            background-color: rgba(245, 158, 11, 0.2);
        }
       
        .highlight-danger {
            background-color: rgba(239, 68, 68, 0.2);
        }
       
        .highlight-active {
            font-weight: bold;
            padding: 2px 4px;
        }
       
        .highlight-success.highlight-active {
            background-color: rgba(16, 185, 129, 0.4);
        }
       
        .highlight-warning.highlight-active {
            background-color: rgba(245, 158, 11, 0.4);
        }
       
        .highlight-danger.highlight-active {
            background-color: rgba(239, 68, 68, 0.4);
        }
       
        .matches-container {
            margin-top: 2rem;
        }
       
        .match-navigation {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }
       
        .match-counter {
            font-size: 0.9rem;
            color: var(--text-light);
        }
       
        .matches-list {
            max-height: 400px;
            overflow-y: auto;
        }
       
        .match-item {
            margin-bottom: 1rem;
            padding: 1rem;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            transition: all 0.2s;
            cursor: pointer;
        }
       
        .match-item:hover {
            border-color: var(--primary-light);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
       
        .match-item-active {
            border-left: 4px solid var(--primary);
            background-color: rgba(79, 70, 229, 0.05);
        }
       
        .match-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
       
        .match-content {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
       
        .match-doc {
            background-color: rgba(229, 231, 235, 0.3);
            padding: 0.5rem;
            border-radius: 0.25rem;
        }
       
        .match-text {
            font-size: 0.9rem;
            margin-top: 0.25rem;
            white-space: pre-wrap;
        }
       
        .btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Plagiarism Detector</h1>
            <p>A tool to check for similarities between documents and manage student submissions</p>
        </header>
       
        <div class="tabs">
            <button class="tab-button active" data-tab="manual-tab">Manual Check</button>
            <button class="tab-button" data-tab="classroom-tab">Google Classroom</button>
            <button class="tab-button" data-tab="reports-tab">Reports</button>
        </div>
       
        <!-- Manual Check Tab -->
        <div id="manual-tab" class="tab-content active">
            <h2>Check Document Similarity</h2>
            <p>Upload two PDF documents to check for similarities</p>
           
            <div class="upload-area">
                <div id="upload-box-1" class="upload-box">
                    <h3>Document 1</h3>
                    <p>Upload a PDF file</p>
                    <input type="file" id="pdf-file-1" class="file-input" accept="application/pdf">
                    <button onclick="document.getElementById('pdf-file-1').click()" class="btn btn-outline">Choose File</button>
                    <div id="file-info-1" class="file-info">
                        <p>No file selected</p>
                    </div>
                </div>
               
                <div id="upload-box-2" class="upload-box">
                    <h3>Document 2</h3>
                    <p>Upload a PDF file</p>
                    <input type="file" id="pdf-file-2" class="file-input" accept="application/pdf">
                    <button onclick="document.getElementById('pdf-file-2').click()" class="btn btn-outline">Choose File</button>
                    <div id="file-info-2" class="file-info">
                        <p>No file selected</p>
                    </div>
                </div>
            </div>
           
            <div class="settings-panel">
                <div class="settings-header" id="settings-toggle">
                    <h3>Analysis Settings</h3>
                    <span>▼</span>
                </div>
               
                <div class="settings-content" id="settings-content">
                    <div class="settings-group">
                        <label for="algorithm-select" class="settings-label">Comparison Algorithm</label>
                        <select id="algorithm-select" class="settings-select">
                            <option value="cosine">Cosine Similarity (general)</option>
                            <option value="jaccard">Jaccard Similarity (mcq)</option>
                            <option value="levenshtein">Levenshtein Distance (suspected copied answers)</option>
                            <option value="ngram">N-gram Similarity (phrase detection, code)</option>
                        </select>
                    </div>
                   
                    <div class="settings-group">
                        <label for="highlight-select" class="settings-label">Display Mode</label>
                        <select id="highlight-select" class="settings-select">
                            <option value="both">Text Highlighting and Match List</option>
                            <option value="inline">Text Highlighting Only</option>
                            <option value="list">Match List Only</option>
                        </select>
                    </div>
                </div>
            </div>
           
            <div class="action-buttons">
                <button id="reset-btn" class="btn btn-outline">Reset</button>
                <button id="analyze-btn" class="btn btn-primary" disabled>Analyze Similarity</button>
            </div>
           
            <div id="result-section">
                <!-- Results will be shown here -->
            </div>
        </div>
       
        <!-- Google Classroom Tab -->
        <div id="classroom-tab" class="tab-content">
            <h2>Google Classroom Integration</h2>
            <p>Connect to Google Classroom to check student submissions for plagiarism</p>
           
            <div id="classroom-login">
                <p>Sign in with your Google account to access your courses</p>
                <button id="google-signin-btn" class="btn btn-primary" disabled>Sign in with Google</button>
            </div>
           
            <div id="classroom-selection">
                <div id="user-profile" class="user-profile">
                    <!-- User profile will be shown here -->
                </div>
               
                <h3>Select a Course</h3>
                <div id="courses-loading" style="text-align: center; padding: 2rem;">
                    <span class="loader" style="border-color: rgba(79, 70, 229, 0.3); border-top-color: var(--primary);"></span>
                    <p>Loading your courses...</p>
                </div>
               
                <div id="course-list" class="course-list">
                    <!-- Course list will be shown here -->
                </div>
               
                <div class="action-buttons">
                    <button id="logout-btn" class="btn btn-outline">Sign Out</button>
                    <button id="select-course-btn" class="btn btn-primary" disabled>View Assignments</button>
                </div>
            </div>
           
            <div id="assignment-section">
                <h3 id="selected-course-name">Assignments</h3>
                <div id="assignments-loading" style="text-align: center; padding: 2rem;">
                    <span class="loader" style="border-color: rgba(79, 70, 229, 0.3); border-top-color: var(--primary);"></span>
                    <p>Loading assignments...</p>
                </div>
               
                <div id="assignment-list">
                    <!-- Assignments will be shown here -->
                </div>
            </div>
        </div>
       
        <!-- Reports Tab -->
        <div id="reports-tab" class="tab-content">
            <h2>Plagiarism Reports</h2>
           
            <div id="no-reports-message" style="text-align: center; padding: 3rem;">
                <p>No reports generated yet. Check for plagiarism in student submissions to generate reports.</p>
            </div>
           
            <div id="report-section">
                <div class="report-header">
                    <div class="report-info">
                        <h3 class="report-title">Plagiarism Analysis for <span id="report-assignment-name"></span></h3>
                        <div class="report-metadata">Generated on <span id="report-date"></span></div>
                    </div>
                    <button id="export-report" class="btn btn-outline" disabled>Export as PDF</button>
                </div>
               
                <!-- Similarity matrix removed as requested -->
               
                <div id="detailed-matches">
                    <!-- Detailed matches will be shown here -->
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
       
        // Google API credentials - this needs your actual API key/client ID
       
       
        // Discovery doc URLs for APIs used by the quickstart
        const DISCOVERY_DOC = 'https://classroom.googleapis.com/$discovery/rest?version=v1';

        // Authorization scopes required by the API
        const SCOPES = [
            'https://www.googleapis.com/auth/classroom.courses.readonly',
            'https://www.googleapis.com/auth/classroom.coursework.me.readonly',
            'https://www.googleapis.com/auth/classroom.coursework.students.readonly',
            'https://www.googleapis.com/auth/classroom.rosters.readonly',
            'https://www.googleapis.com/auth/classroom.profile.emails',
            'https://www.googleapis.com/auth/classroom.profile.photos'
        ];

        let tokenClient;
        let gapiInited = false;
        let gisInited = false;
        let selectedCourseId = null;
        let courses = [];
        let assignments = [];
        let userProfile = null;
       
        // Tab navigation
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                // Remove active class from all tabs and contents
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
               
                // Add active class to clicked tab and corresponding content
                button.classList.add('active');
                const tabId = button.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
            });
        });

        /**
         * Load the Google API client library and initialize
         */
        function loadGoogleAPI() {
            const script = document.createElement('script');
            script.src = 'https://apis.google.com/js/api.js';
            script.onload = gapiLoaded;
            document.body.appendChild(script);

            const gisScript = document.createElement('script');
            gisScript.src = 'https://accounts.google.com/gsi/client';
            gisScript.onload = gisLoaded;
            document.body.appendChild(gisScript);
        }

        /**
         * Callback after the Google API client is loaded
         */
        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        /**
         * Callback after the Google Identity Services library is loaded
         */
        function gisLoaded() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES.join(' '),
                // IMPORTANT: Adding the correct redirect URI - must match what's in Google Cloud Console
                redirect_uri: window.location.origin + window.location.pathname,
                callback: (resp) => {
                    if (resp.error !== undefined) {
                        showError('Error authenticating with Google: ' + resp.error);
                        return;
                    }
                    // Authentication successful, now get user information and courses
                    getUserProfileAndCourses();
                }
            });
            gisInited = true;
            updateSigninStatus();
        }

        /**
         * Initialize the Google API client
         */
        async function initializeGapiClient() {
            try {
                await gapi.client.init({
                    apiKey: API_KEY,
                    discoveryDocs: [DISCOVERY_DOC],
                });
                gapiInited = true;
                updateSigninStatus();
            } catch (err) {
                showError('Error initializing Google API client: ' + err.message);
            }
        }

        /**
         * Update UI based on sign-in status
         */
        function updateSigninStatus() {
            const googleSigninBtn = document.getElementById('google-signin-btn');
           
            if (gapiInited && gisInited) {
                googleSigninBtn.disabled = false;
            }
        }

        /**
         * Sign in the user with Google
         */
        function handleAuthClick() {
            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) {
                    showError('Error authenticating with Google: ' + resp.error);
                    return;
                }
                await getUserProfileAndCourses();
            };

            if (gapi.client.getToken() === null) {
                // Display the One Tap UI
                tokenClient.requestAccessToken({ prompt: 'consent' });
            } else {
                // Skip the One Tap UI if the user has already signed in
                tokenClient.requestAccessToken({ prompt: '' });
            }
        }

        /**
         * Sign out the user
         */
        function handleSignoutClick() {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
               
                // Reset UI
                document.getElementById('classroom-login').style.display = 'flex';
                document.getElementById('classroom-selection').style.display = 'none';
                document.getElementById('assignment-section').style.display = 'none';
                document.getElementById('course-list').innerHTML = '';
                document.getElementById('assignment-list').innerHTML = '';
                selectedCourseId = null;
                courses = [];
                assignments = [];
                userProfile = null;
            }
        }

        /**
         * Get user profile info and list of courses
         */
        async function getUserProfileAndCourses() {
            try {
                // Get user profile info
                const peopleResponse = await gapi.client.classroom.userProfiles.get({
                    userId: 'me'
                });
                userProfile = peopleResponse.result;
               
                // Update UI with user profile
                const userProfileDiv = document.getElementById('user-profile');
                userProfileDiv.innerHTML = `
                    <div class="user-avatar">
                        <img src="${userProfile.photoUrl || 'https://via.placeholder.com/40'}" alt="${userProfile.name.fullName}">
                    </div>
                    <div>
                        <div class="user-name">${userProfile.name.fullName}</div>
                        <div class="user-email">${userProfile.emailAddress}</div>
                    </div>
                `;
               
                // Show course selection UI
                document.getElementById('classroom-login').style.display = 'none';
                document.getElementById('classroom-selection').style.display = 'block';
               
                // Get courses
                await listCourses();
            } catch (err) {
                showError('Error getting user profile or courses: ' + err.message);
            }
        }

        /**
         * List courses the user has access to
         */
        async function listCourses() {
            try {
                document.getElementById('courses-loading').style.display = 'block';
                document.getElementById('course-list').innerHTML = '';
               
                const response = await gapi.client.classroom.courses.list({
                    pageSize: 20,
                    courseStates: ['ACTIVE']
                });
               
                const courseList = document.getElementById('course-list');
                courses = response.result.courses || [];
               
                if (courses.length === 0) {
                    courseList.innerHTML = '<p>No active courses found.</p>';
                    document.getElementById('courses-loading').style.display = 'none';
                    return;
                }
               
                let courseHTML = '';
                courses.forEach(course => {
                    // Check if course has courseState of ACTIVE
                    if (course.courseState === 'ACTIVE') {
                        courseHTML += `
                            <div class="course-card" data-course-id="${course.id}">
                                <div class="course-name">${course.name}</div>
                                <div class="course-details">
                                    ${course.section ? course.section + ' · ' : ''}
                                    ${course.room ? 'Room ' + course.room : ''}
                                </div>
                            </div>
                        `;
                    }
                });
               
                courseList.innerHTML = courseHTML;
               
                // Add click event listeners to course cards
                document.querySelectorAll('.course-card').forEach(card => {
                    card.addEventListener('click', () => {
                        // Remove selected class from all cards
                        document.querySelectorAll('.course-card').forEach(c => c.classList.remove('selected'));
                        // Add selected class to clicked card
                        card.classList.add('selected');
                        selectedCourseId = card.getAttribute('data-course-id');
                        document.getElementById('select-course-btn').disabled = false;
                    });
                });
               
                document.getElementById('courses-loading').style.display = 'none';
            } catch (err) {
                showError('Error listing courses: ' + err.message);
                document.getElementById('courses-loading').style.display = 'none';
            }
        }

        /**
         * List assignments for the selected course
         */
        async function listAssignments(courseId) {
            try {
                document.getElementById('assignment-section').style.display = 'block';
                document.getElementById('assignments-loading').style.display = 'block';
                document.getElementById('assignment-list').innerHTML = '';
               
                // Update selected course name
                const selectedCourse = courses.find(course => course.id === courseId);
                document.getElementById('selected-course-name').textContent = `Assignments for ${selectedCourse.name}`;
               
                const response = await gapi.client.classroom.courses.courseWork.list({
                    courseId: courseId,
                    pageSize: 50,
                    orderBy: 'dueDate desc'
                });
               
                const assignmentList = document.getElementById('assignment-list');
                assignments = response.result.courseWork || [];
               
                if (assignments.length === 0) {
                    assignmentList.innerHTML = '<p>No assignments found in this course.</p>';
                    document.getElementById('assignments-loading').style.display = 'none';
                    return;
                }
               
                let assignmentHTML = '';
                for (const assignment of assignments) {
                    // Get submissions for this assignment
                    const submissionsResponse = await gapi.client.classroom.courses.courseWork.studentSubmissions.list({
                        courseId: courseId,
                        courseWorkId: assignment.id
                    });
                   
                    const submissions = submissionsResponse.result.studentSubmissions || [];
                    const submittedCount = submissions.filter(sub => sub.state === 'TURNED_IN' || sub.state === 'RETURNED').length;
                   
                    // Format due date if it exists
                    let dueDate = 'No due date';
                    if (assignment.dueDate) {
                        const date = new Date(
                            assignment.dueDate.year,
                            assignment.dueDate.month - 1,
                            assignment.dueDate.day,
                            assignment.dueTime ? assignment.dueTime.hours || 0 : 0,
                            assignment.dueTime ? assignment.dueTime.minutes || 0 : 0
                        );
                        dueDate = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                    }
                   
                    assignmentHTML += `
                        <div class="assignment-item">
                            <div class="assignment-header">
                                <div class="assignment-title">${assignment.title}</div>
                                <div class="assignment-due">Due: ${dueDate}</div>
                            </div>
                            <div>
                                <p>${assignment.description || 'No description provided.'}</p>
                                <div class="assignment-meta">
                                    <span class="badge ${submittedCount > 0 ? 'badge-success' : 'badge-warning'}">
                                        ${submittedCount} Submissions
                                    </span>
                                </div>
                            </div>
                            <div class="assignment-submissions">
                                <div class="batch-action">
                                    <span>Student submissions</span>
                                    <button class="btn btn-primary check-plagiarism-btn" data-assignment-id="${assignment.id}">
                                        Check for Plagiarism
                                    </button>
                                </div>
                                <ul class="submission-list">
                    `;
                   
                    if (submissions.length === 0) {
                        assignmentHTML += `<li>No submissions yet.</li>`;
                    } else {
                        // Get student profiles for this course
                        const studentsResponse = await gapi.client.classroom.courses.students.list({
                            courseId: courseId
                        });
                       
                        const students = studentsResponse.result.students || [];
                        const studentMap = {};
                        students.forEach(student => {
                            studentMap[student.userId] = student.profile.name.fullName;
                        });
                       
                        // Filter for actual submissions
                        const actualSubmissions = submissions.filter(sub =>
                            sub.state === 'TURNED_IN' || sub.state === 'RETURNED'
                        );
                       
                        for (let i = 0; i < Math.min(actualSubmissions.length, 5); i++) {
                            const sub = actualSubmissions[i];
                            const studentName = studentMap[sub.userId] || 'Unknown Student';
                           
                            assignmentHTML += `
                                <li class="submission-item">
                                    <div class="student-name">${studentName}</div>
                                    <div class="submission-actions">
                                        <button class="btn btn-outline btn-sm view-submission-btn"
                                                data-submission-id="${sub.id}"
                                                data-student-id="${sub.userId}"
                                                data-student-name="${studentName}"
                                                data-course-id="${courseId}"
                                                data-assignment-id="${assignment.id}">
                                            View
                                        </button>
                                    </div>
                                </li>
                            `;
                        }
                       
                        if (actualSubmissions.length > 5) {
                            assignmentHTML += `
                                <li class="submission-item">
                                    <div>And ${actualSubmissions.length - 5} more submissions...</div>
                                </li>
                            `;
                        }
                    }
                   
                    assignmentHTML += `
                                </ul>
                            </div>
                        </div>
                    `;
                }
               
                assignmentList.innerHTML = assignmentHTML;
               
                // Add event listeners to plagiarism check buttons
                document.querySelectorAll('.check-plagiarism-btn').forEach(button => {
                    button.addEventListener('click', () => {
                        const assignmentId = button.getAttribute('data-assignment-id');
                        checkPlagiarism(courseId, assignmentId);
                    });
                });
               
                // Add event listeners to view submission buttons
                document.querySelectorAll('.view-submission-btn').forEach(button => {
                    button.addEventListener('click', () => {
                        const submissionId = button.getAttribute('data-submission-id');
                        const studentId = button.getAttribute('data-student-id');
                        const studentName = button.getAttribute('data-student-name');
                        const assignmentId = button.getAttribute('data-assignment-id');
                        viewSubmission(courseId, assignmentId, submissionId, studentId, studentName);
                    });
                });
               
                document.getElementById('assignments-loading').style.display = 'none';
            } catch (err) {
                showError('Error listing assignments: ' + err.message);
                document.getElementById('assignments-loading').style.display = 'none';
            }
        }

        /**
         * Check plagiarism across all submissions for an assignment
         */
         async function checkPlagiarism(courseId, assignmentId) {
    try {
        const selectedAssignment = assignments.find(a => a.id === assignmentId);
        if (!selectedAssignment) {
            showError('Assignment not found');
            return;
        }
       
        // Show loading state
        const button = document.querySelector(`.check-plagiarism-btn[data-assignment-id="${assignmentId}"]`);
        const originalText = button.textContent;
        button.innerHTML = `<span class="loader"></span> Analyzing...`;
        button.disabled = true;
       
        // Get all submissions for this assignment
        const submissionsResponse = await gapi.client.classroom.courses.courseWork.studentSubmissions.list({
            courseId: courseId,
            courseWorkId: assignmentId
        });
       
        const submissions = submissionsResponse.result.studentSubmissions || [];
        const validSubmissions = submissions.filter(sub =>
            (sub.state === 'TURNED_IN' || sub.state === 'RETURNED') &&
            sub.assignmentSubmission &&
            sub.assignmentSubmission.attachments
        );
       
        if (validSubmissions.length < 2) {
            showError('Need at least 2 valid submissions to check for plagiarism');
            button.innerHTML = originalText;
            button.disabled = false;
            return;
        }
       
        // Get student profiles for this course
        const studentsResponse = await gapi.client.classroom.courses.students.list({
            courseId: courseId
        });
       
        const students = studentsResponse.result.students || [];
        const studentMap = {};
        students.forEach(student => {
            studentMap[student.userId] = student.profile.name.fullName;
        });
       
        // Array to store actual submission content
        const submissionData = [];
       
        // Process each valid submission
        for (const sub of validSubmissions) {
            try {
                // Get student name
                const studentName = studentMap[sub.userId] || 'Unknown Student';
               
                // Initialize content placeholder
                let submissionContent = '';
               
                if (sub.assignmentSubmission && sub.assignmentSubmission.attachments) {
                    // Process each attachment
                    for (const attachment of sub.assignmentSubmission.attachments) {
                        if (attachment.driveFile) {
                            try {
                                // Get file details
                                const fileId = attachment.driveFile.id;
                                const fileName = attachment.driveFile.title || 'Unnamed file';
                                const fileType = attachment.driveFile.alternateLink ?
                                    attachment.driveFile.alternateLink.split('.').pop() : 'unknown';
                                   
                                // For a real implementation, here's where we would:
                                // 1. Initialize Google Drive API access
                                // 2. Download the file content using gapi.client.drive.files.get()
                                // 3. Extract text from the file based on its type (PDF, DOCX, etc.)
                               
                                // For now, we'll use the real Drive API to fetch file metadata
                                // but simulate content extraction since we can't fully implement Drive API
                               
                                // First, try to get metadata for the file
                                try {
                                    // This will authenticate and check if we have access to the file
                                    const fileMetadata = await new Promise((resolve, reject) => {
                                        // If Drive API is loaded, use it to get file metadata
                                        if (gapi.client.drive) {
                                            gapi.client.drive.files.get({
                                                fileId: fileId,
                                                fields: 'id,name,mimeType,webContentLink'
                                            }).then(response => {
                                                resolve(response.result);
                                            }).catch(err => {
                                                reject(err);
                                            });
                                        } else {
                                            // If Drive API not loaded, provide basic info from attachment
                                            resolve({
                                                id: fileId,
                                                name: fileName,
                                                mimeType: 'application/octet-stream'
                                            });
                                        }
                                    });
                                   
                                    // Based on mime type, we would extract text differently
                                    const mimeType = fileMetadata.mimeType || '';
                                   
                                    // For demonstration, use the actual text extraction function
                                    // with realistic sample content instead of random text
                                    submissionContent += await getDocumentContent(fileId, mimeType, sub.userId);
                                   
                                } catch (metadataErr) {
                                    console.error('Error getting file metadata:', metadataErr);
                                    // Fall back to document identifier if we can't get content
                                    submissionContent += `Content from file: ${fileName} (ID: ${fileId})\n`;
                                }
                               
                            } catch (fileErr) {
                                console.error('Error processing file:', fileErr);
                                submissionContent += `Error accessing file content: ${fileErr.message}\n`;
                            }
                        } else if (attachment.link) {
                            // For link attachments, we would fetch the page content
                            submissionContent += `Content from link: ${attachment.link.url}\n`;
                           
                            // TODO: Implement web scraping for link content
                            // For now, use a sample text based on URL hash
                            const urlHash = hashString(attachment.link.url);
                            submissionContent += await getWebContent(attachment.link.url, urlHash);
                           
                        } else if (attachment.youtubeVideo) {
                            // For YouTube videos, we would use YouTube transcript API
                            submissionContent += `Content from YouTube video: ${attachment.youtubeVideo.title}\n`;
                            // For now, add a placeholder
                            submissionContent += "This is a placeholder for YouTube video content that would normally be extracted from captions/transcript.";
                        } else if (attachment.form) {
                            // For Google Forms, we would use Forms API
                            submissionContent += `Content from Google Form: ${attachment.form.title}\n`;
                            // For now, add a placeholder
                            submissionContent += "This is a placeholder for Google Form response content.";
                        }
                    }
                }
               
                // Add to submission data
                submissionData.push({
                    id: sub.id,
                    userId: sub.userId,
                    studentName: studentName,
                    content: submissionContent || `No extractable content for ${studentName}`
                });
               
            } catch (subErr) {
                console.error('Error processing submission:', subErr);
                submissionData.push({
                    id: sub.id,
                    userId: sub.userId,
                    studentName: studentMap[sub.userId] || 'Unknown Student',
                    content: `Error processing submission: ${subErr.message}`
                });
            }
        }
       
        // Create similarity matrix based on actual submission content
        const similarityMatrix = [];
       
        for (let i = 0; i < submissionData.length; i++) {
            const row = [];
            for (let j = 0; j < submissionData.length; j++) {
                if (i === j) {
                    row.push(100); // Same document has 100% similarity
                } else {
                    // Calculate actual similarity using text comparison of real content
                    const similarity = calculateCosineSimilarity(
                        submissionData[i].content,
                        submissionData[j].content
                    );
                   
                    // Convert to percentage
                    const similarityPercentage = Math.round(similarity * 100);
                    row.push(similarityPercentage);
                }
            }
            similarityMatrix.push(row);
        }
       
        // Generate and display report
        generatePlagiarismReport(selectedAssignment, submissionData, similarityMatrix);
       
        // Switch to reports tab
        document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        document.querySelector('.tab-button[data-tab="reports-tab"]').classList.add('active');
        document.getElementById('reports-tab').classList.add('active');
       
        // Reset button
        button.innerHTML = originalText;
        button.disabled = false;
       
    } catch (err) {
        showError('Error checking plagiarism: ' + err.message);
        const button = document.querySelector(`.check-plagiarism-btn[data-assignment-id="${assignmentId}"]`);
        if (button) {
            button.textContent = 'Check for Plagiarism';
            button.disabled = false;
        }
    }
}

        /**
         * Helper function to create a hash from a string
         */
        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return Math.abs(hash);
        }
       
        /**
         * Generate and display a plagiarism report
         */
        function generatePlagiarismReport(assignment, submissionData, similarityMatrix) {
            // Show report section
            document.getElementById('report-section').style.display = 'block';
            document.getElementById('no-reports-message').style.display = 'none';
           
            // Update report info
            document.getElementById('report-assignment-name').textContent = assignment.title;
            document.getElementById('report-date').textContent = new Date().toLocaleDateString();
           
            // Find significant matches (similarity > 50%)
            const significantMatches = [];
            for (let i = 0; i < submissionData.length; i++) {
                for (let j = i + 1; j < submissionData.length; j++) {
                    if (similarityMatrix[i][j] > 50) {
                        significantMatches.push({
                            student1: submissionData[i],
                            student2: submissionData[j],
                            similarity: similarityMatrix[i][j]
                        });
                    }
                }
            }
           
            // Sort by similarity (highest first)
            significantMatches.sort((a, b) => b.similarity - a.similarity);
           
            // Generate detailed matches
            const detailedMatches = document.getElementById('detailed-matches');
            let matchesHTML = '<h3>Matching Segments</h3>';
           
            if (significantMatches.length === 0) {
                matchesHTML += '<p>No significant matches found.</p>';
            } else {
                significantMatches.forEach(match => {
                    let colorClass = 'success';
                    if (match.similarity > 70) colorClass = 'danger';
                    else if (match.similarity > 50) colorClass = 'warning';
                   
                    matchesHTML += `
                        <div class="card" style="margin-bottom: 1rem; padding: 1rem; border: 1px solid var(--border); border-radius: 0.5rem;">
                            <h4>
                                <span class="badge badge-${colorClass}">${match.similarity}% Similarity</span>
                                ${match.student1.studentName} & ${match.student2.studentName}
                            </h4>
                            <div class="buttons" style="margin-top: 0.75rem;">
                                <button class="btn btn-outline btn-sm view-match-btn"
                                        data-student1="${match.student1.userId}"
                                        data-student2="${match.student2.userId}"
                                        data-student1-name="${match.student1.studentName}"
                                        data-student2-name="${match.student2.studentName}"
                                        data-student1-content="${encodeURIComponent(match.student1.content)}"
                                        data-student2-content="${encodeURIComponent(match.student2.content)}">
                                    View Match Details
                                </button>
                            </div>
                        </div>
                    `;
                });
            }
           
            detailedMatches.innerHTML = matchesHTML;
           
            // Add event listeners to view match buttons
            document.querySelectorAll('.view-match-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const student1Id = button.getAttribute('data-student1');
                    const student2Id = button.getAttribute('data-student2');
                    const student1Name = button.getAttribute('data-student1-name');
                    const student2Name = button.getAttribute('data-student2-name');
                    const student1Content = decodeURIComponent(button.getAttribute('data-student1-content'));
                    const student2Content = decodeURIComponent(button.getAttribute('data-student2-content'));
                   
                    viewMatchDetails(
                        student1Id,
                        student2Id,
                        student1Name,
                        student2Name,
                        student1Content,
                        student2Content
                    );
                });
            });
           
            // Create and enable export report button
            const exportButton = document.getElementById('export-report');
            if (exportButton) {
                exportButton.disabled = false;
                exportButton.addEventListener('click', () => {
                    exportPlagiarismReport(assignment, submissionData, similarityMatrix, significantMatches);
                });
            }
        }

        /**
         * Export plagiarism report to PDF
         */
        function exportPlagiarismReport(assignment, submissionData, similarityMatrix, significantMatches) {
            try {
                // Create new PDF document
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
               
                let yPosition = 20;
               
                // Add title
                doc.setFontSize(18);
                doc.text('Plagiarism Analysis Report', 105, yPosition, { align: 'center' });
                yPosition += 10;
               
                // Add assignment info
                doc.setFontSize(12);
                doc.text(`Assignment: ${assignment.title}`, 20, yPosition);
                yPosition += 7;
                doc.text(`Date: ${new Date().toLocaleDateString()}`, 20, yPosition);
                yPosition += 15;
               
                // Add summary
                doc.setFontSize(14);
                doc.text('Summary', 20, yPosition);
                yPosition += 10;
               
                doc.setFontSize(11);
                doc.text(`Total submissions analyzed: ${submissionData.length}`, 20, yPosition);
                yPosition += 7;
                doc.text(`Significant matches found: ${significantMatches.length}`, 20, yPosition);
                yPosition += 15;
               
                // Add significant matches
                if (significantMatches.length > 0) {
                    doc.setFontSize(14);
                    doc.text('Significant Matches', 20, yPosition);
                    yPosition += 10;
                   
                    doc.setFontSize(10);
                    significantMatches.forEach((match, index) => {
                        // Check if we need a new page
                        if (yPosition > 250) {
                            doc.addPage();
                            yPosition = 20;
                        }
                       
                        doc.text(`Match ${index + 1}: ${match.student1.studentName} & ${match.student2.studentName}`, 20, yPosition);
                        yPosition += 5;
                        doc.text(`Similarity: ${match.similarity}%`, 30, yPosition);
                        yPosition += 10;
                    });
                }
               
                // If there are enough students, add similarity matrix visualization
                if (submissionData.length <= 10) {
                    // Check if we need a new page
                    if (yPosition > 150) {
                        doc.addPage();
                        yPosition = 20;
                    }
                   
                    doc.setFontSize(14);
                    doc.text('Similarity Matrix', 20, yPosition);
                    yPosition += 10;
                   
                    // Simple matrix representation in the PDF
                    const cellWidth = 160 / submissionData.length;
                    const cellHeight = 10;
                   
                    // Student IDs on top
                    for (let i = 0; i < submissionData.length; i++) {
                        doc.setFontSize(8);
                        doc.text(`S${i+1}`, 40 + i * cellWidth, yPosition, { align: 'center' });
                    }
                    yPosition += 5;
                   
                    // Matrix cells
                    for (let i = 0; i < submissionData.length; i++) {
                        doc.setFontSize(8);
                        doc.text(`S${i+1}`, 30, yPosition + i * cellHeight + 5);
                       
                        for (let j = 0; j < submissionData.length; j++) {
                            const similarity = similarityMatrix[i][j];
                           
                            // Draw colored rectangle based on similarity
                            if (similarity > 70) {
                                doc.setFillColor(255, 100, 100);  // Red for high similarity
                            } else if (similarity > 50) {
                                doc.setFillColor(255, 200, 100);  // Orange for medium similarity
                            } else {
                                doc.setFillColor(100, 200, 100);  // Green for low similarity
                            }
                           
                            doc.rect(40 + j * cellWidth - cellWidth/2, yPosition + i * cellHeight, cellWidth, cellHeight, 'F');
                           
                            // Add percentage text
                            doc.setTextColor(0);
                            doc.text(`${similarity}%`, 40 + j * cellWidth, yPosition + i * cellHeight + 6, { align: 'center' });
                        }
                    }
                    yPosition += submissionData.length * cellHeight + 15;
                }
               
                // Add note about the report
                doc.setFontSize(10);
                doc.text('Note: This report highlights potential similarities between student submissions.', 20, yPosition);
                yPosition += 5;
                doc.text('Further investigation is recommended for high similarity matches.', 20, yPosition);
               
                // Save the PDF
                doc.save(`Plagiarism_Report_${assignment.title.replace(/\s+/g, '_')}.pdf`);
               
            } catch (err) {
                console.error('Error exporting report:', err);
                showError('Error exporting report: ' + err.message);
            }
        }

        /**
         * View details of a specific submission
         */
        function viewSubmission(courseId, assignmentId, submissionId, studentId, studentName) {
            // In a real application, you would fetch the submission attachments
            // For now, just show a message with the student's name
            alert(`Viewing submission by ${studentName}`);
        }
       
        /**
         * View details of a plagiarism match between two students
         */
         function viewMatchDetails(student1Id, student2Id, student1Name, student2Name, student1Content, student2Content) {
    try {
        // Create a modal for comparison
        const modalContainer = document.createElement('div');
        modalContainer.className = 'modal-container';
       
        const modalContent = document.createElement('div');
        modalContent.className = 'modal-content';
       
        // Find common text by highlighting similar phrases
        const highlightedContent = highlightSimilarText(student1Content, student2Content);
       
        modalContent.innerHTML = `
            <div class="modal-header">
                <h3>Similarity Match Details</h3>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="comparison-container">
                    <div class="comparison-side">
                        <h4>${student1Name}'s Submission</h4>
                        <div class="comparison-content">
                            ${highlightedContent.text1}
                        </div>
                    </div>
                    <div class="comparison-side">
                        <h4>${student2Name}'s Submission</h4>
                        <div class="comparison-content">
                            ${highlightedContent.text2}
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary close-modal">Close</button>
            </div>
        `;
       
        modalContainer.appendChild(modalContent);
        document.body.appendChild(modalContainer);
       
        // Add close functionality
        modalContainer.querySelectorAll('.close-modal').forEach(button => {
            button.addEventListener('click', () => {
                document.body.removeChild(modalContainer);
            });
        });
       
        // Close when clicking outside the modal
        modalContainer.addEventListener('click', (e) => {
            if (e.target === modalContainer) {
                document.body.removeChild(modalContainer);
            }
        });
       
    } catch (err) {
        console.error('Error showing match details:', err);
        showError('Error showing match details: ' + err.message);
    }
}
        /**
         * Highlight similar text between two submissions
         */
         function highlightSimilarText(text1, text2) {
    // Split texts into sentences
    const sentences1 = text1.split(/(?<=[.!?])\s+/);
    const sentences2 = text2.split(/(?<=[.!?])\s+/);
   
    let highlighted1 = '';
    let highlighted2 = '';
   
    // Track which sentences in text2 have been matched to avoid duplicate highlighting
    const matchedSentences = new Set();
   
    // First pass: identify similar sentences and highlight them
    for (let i = 0; i < sentences1.length; i++) {
        let bestMatchIndex = -1;
        let bestMatchScore = 0;
       
        // Find the best matching sentence in text2
        for (let j = 0; j < sentences2.length; j++) {
            if (matchedSentences.has(j)) continue; // Skip already matched sentences
           
            const similarity = calculateSimilarity(sentences1[i], sentences2[j]);
            if (similarity > 0.7 && similarity > bestMatchScore) {
                bestMatchScore = similarity;
                bestMatchIndex = j;
            }
        }
       
        // Add the sentence with appropriate highlighting
        if (bestMatchIndex !== -1) {
            // Add highlighting with similarity percentage
            const similarityPercent = Math.round(bestMatchScore * 100);
            let colorClass = 'success';
            if (similarityPercent > 80) colorClass = 'danger';
            else if (similarityPercent > 60) colorClass = 'warning';
           
            highlighted1 += `<p class="highlight highlight-${colorClass}" title="${similarityPercent}% similar">${sentences1[i]}</p>`;
           
            // Mark this sentence as matched
            matchedSentences.add(bestMatchIndex);
        } else {
            highlighted1 += `<p>${sentences1[i]}</p>`;
        }
    }
   
    // Reset matched sentences for second pass
    matchedSentences.clear();
   
    // Second pass: highlight matching sentences in text2
    for (let j = 0; j < sentences2.length; j++) {
        let bestMatchIndex = -1;
        let bestMatchScore = 0;
       
        // Find the best matching sentence in text1
        for (let i = 0; i < sentences1.length; i++) {
            if (matchedSentences.has(i)) continue; // Skip already matched sentences
           
            const similarity = calculateSimilarity(sentences2[j], sentences1[i]);
            if (similarity > 0.7 && similarity > bestMatchScore) {
                bestMatchScore = similarity;
                bestMatchIndex = i;
            }
        }
       
        // Add the sentence with appropriate highlighting
        if (bestMatchIndex !== -1) {
            // Add highlighting with similarity percentage
            const similarityPercent = Math.round(bestMatchScore * 100);
            let colorClass = 'success';
            if (similarityPercent > 80) colorClass = 'danger';
            else if (similarityPercent > 60) colorClass = 'warning';
           
            highlighted2 += `<p class="highlight highlight-${colorClass}" title="${similarityPercent}% similar">${sentences2[j]}</p>`;
           
            // Mark this sentence as matched
            matchedSentences.add(bestMatchIndex);
        } else {
            highlighted2 += `<p>${sentences2[j]}</p>`;
        }
    }
   
    return {
        text1: highlighted1,
        text2: highlighted2
    };
}
       
        /**
         * Calculate similarity between two text strings
         */
        function calculateSimilarity(text1, text2) {
            // Convert to lowercase and split into words
            const words1 = text1.toLowerCase().split(/\W+/).filter(word => word.length > 0);
            const words2 = text2.toLowerCase().split(/\W+/).filter(word => word.length > 0);
           
            // Count shared words
            const set1 = new Set(words1);
            const set2 = new Set(words2);
           
            let sharedWords = 0;
            for (const word of set1) {
                if (set2.has(word)) {
                    sharedWords++;
                }
            }
           
            // Calculate Jaccard similarity
            const union = set1.size + set2.size - sharedWords;
            return union === 0 ? 0 : sharedWords / union;
        }
       
        /**
         * Show an error message to the user
         */
        function showError(message) {
            alert(`Error: ${message}`);
            console.error(message);
        }
       
        /**
         * Initialize the PDF upload functionality
         */
        function initPDFUploader() {
            const fileInputs = [
                document.getElementById('pdf-file-1'),
                document.getElementById('pdf-file-2')
            ];
            const uploadBoxes = [
                document.getElementById('upload-box-1'),
                document.getElementById('upload-box-2')
            ];
            const fileInfos = [
                document.getElementById('file-info-1'),
                document.getElementById('file-info-2')
            ];
            const analyzeBtn = document.getElementById('analyze-btn');
            const resetBtn = document.getElementById('reset-btn');
            const resultSection = document.getElementById('result-section');
           
            // Document text storage
            let documentTexts = [null, null];
           
            // Handle file selection
            fileInputs.forEach((input, index) => {
                input.addEventListener('change', async function() {
                    if (this.files && this.files[0]) {
                        const file = this.files[0];
                        if (file.type === 'application/pdf') {
                            try {
                                // Show loading state
                                uploadBoxes[index].classList.add('active');
                                fileInfos[index].innerHTML = `
                                    <p>Selected file: <span class="file-name">${file.name}</span></p>
                                    <p>Size: ${(file.size / 1024).toFixed(2)} KB</p>
                                    <p><span class="loader"></span> Extracting text...</p>
                                `;
                               
                                // Extract text from PDF
                                const text = await extractTextFromPDF(file);
                                documentTexts[index] = text;
                               
                                fileInfos[index].innerHTML = `
                                    <p>Selected file: <span class="file-name">${file.name}</span></p>
                                    <p>Size: ${(file.size / 1024).toFixed(2)} KB</p>
                                    <p>Characters: ${text.length}</p>
                                    <p class="badge badge-success">Text extracted successfully</p>
                                `;
                               
                                // Enable analyze button if both files have text
                                if (documentTexts[0] && documentTexts[1]) {
                                    analyzeBtn.disabled = false;
                                }
                            } catch (err) {
                                console.error('Error extracting text:', err);
                                fileInfos[index].innerHTML = `
                                    <p>Selected file: <span class="file-name">${file.name}</span></p>
                                    <p>Size: ${(file.size / 1024).toFixed(2)} KB</p>
                                    <p class="badge badge-danger">Error extracting text</p>
                                `;
                                documentTexts[index] = null;
                                analyzeBtn.disabled = true;
                            }
                        } else {
                            showError('Please select a PDF file');
                            this.value = '';
                            documentTexts[index] = null;
                            analyzeBtn.disabled = true;
                        }
                    }
                });
            });
           
            // Analyze button click handler
            analyzeBtn.addEventListener('click', async function() {
                try {
                    // Show loading state
                    analyzeBtn.innerHTML = '<span class="loader"></span> Analyzing...';
                    analyzeBtn.disabled = true;
                   
                    // Get algorithm and display mode
                    const algorithm = document.getElementById('algorithm-select').value;
                    const highlightType = document.getElementById('highlight-select').value;
                   
                    // Compare documents and find similarities
                    const { similarityScore, matches } = findSimilarities(documentTexts[0], documentTexts[1], algorithm);
                   
                    let resultMessage, resultClass;
                   
                    if (similarityScore < 30) {
                        resultMessage = 'Low similarity detected. The documents are likely original.';
                        resultClass = 'success';
                    } else if (similarityScore < 70) {
                        resultMessage = 'Moderate similarity detected. Some content may be overlapping.';
                        resultClass = 'warning';
                    } else {
                        resultMessage = 'High similarity detected. The documents may contain plagiarized content.';
                        resultClass = 'danger';
                    }
                   
                    // Create document comparison view
                    let documentViewHTML = '';
                   
                    if (highlightType === 'inline' || highlightType === 'both') {
                        documentViewHTML = `
                            <div class="document-comparison">
                                <div class="document-side">
                                    <h3>Document 1</h3>
                                    <div class="document-content" id="document1-content"></div>
                                </div>
                                <div class="document-side">
                                    <h3>Document 2</h3>
                                    <div class="document-content" id="document2-content"></div>
                                </div>
                            </div>
                        `;
                    }
                   
                    // Create matches list view
                    let matchesListHTML = '';
                    if (highlightType === 'list' || highlightType === 'both') {
                        matchesListHTML = `
                            <div class="matches-container">
                                <h3>Matching Segments (${matches.length})</h3>
                                <div class="match-navigation">
                                    <button id="prev-match" class="btn btn-outline btn-sm" disabled>← Previous</button>
                                    <span id="match-counter">Match 0 of ${matches.length}</span>
                                    <button id="next-match" class="btn btn-outline btn-sm" ${matches.length > 0 ? '' : 'disabled'}>Next →</button>
                                </div>
                                <div class="matches-list" id="matches-list"></div>
                            </div>
                        `;
                    }
                   
                    // Display result
                    resultSection.innerHTML = `
                        <h2>Similarity Analysis Result</h2>
                        <div class="similarity-result">
                            <div class="similarity-gauge">
                                <svg viewBox="0 0 100 50" class="gauge">
                                    <path d="M 10 40 A 40 40 0 1 1 90 40" stroke="#e5e7eb" stroke-width="10" fill="none"></path>
                                    <path d="M 10 40 A 40 40 0 1 1 90 40" stroke="var(--${resultClass})" stroke-width="10" fill="none" stroke-dasharray="${similarityScore}, 100"></path>
                                    <text x="50" y="45" text-anchor="middle" font-size="20" font-weight="bold">${similarityScore}%</text>
                                </svg>
                            </div>
                            <div class="alert alert-${resultClass}">
                                <p>${resultMessage}</p>
                            </div>
                        </div>
                       
                        ${documentViewHTML}
                        ${matchesListHTML}
                    `;
                    resultSection.style.display = 'block';
                   
                    // Populate document views with highlighted text
                    if (highlightType === 'inline' || highlightType === 'both') {
                        populateDocumentView('document1-content', documentTexts[0], matches, 0);
                        populateDocumentView('document2-content', documentTexts[1], matches, 1);
                    }
                   
                    // Populate matches list
                    if (highlightType === 'list' || highlightType === 'both') {
                        populateMatchesList('matches-list', matches, documentTexts);
                    }
                   
                    // Set up match navigation
                    setupMatchNavigation(matches);
                   
                    // Reset analyze button
                    analyzeBtn.innerHTML = 'Analyze Similarity';
                    analyzeBtn.disabled = false;
                   
                } catch (err) {
                    console.error('Error analyzing documents:', err);
                    showError('Error analyzing documents: ' + err.message);
                    analyzeBtn.innerHTML = 'Analyze Similarity';
                    analyzeBtn.disabled = false;
                }
            });
           
            // Reset button click handler
            resetBtn.addEventListener('click', function() {
                fileInputs.forEach((input, index) => {
                    input.value = '';
                    uploadBoxes[index].classList.remove('active');
                    fileInfos[index].innerHTML = '<p>No file selected</p>';
                    documentTexts[index] = null;
                });
                analyzeBtn.disabled = true;
                resultSection.style.display = 'none';
            });
        }

        /**
         * Extract text from PDF file
         */
        async function extractTextFromPDF(file) {
            return new Promise((resolve, reject) => {
                const fileReader = new FileReader();
               
                fileReader.onload = async function() {
                    try {
                        const typedArray = new Uint8Array(this.result);
                        const pdfDoc = await pdfjsLib.getDocument(typedArray).promise;
                       
                        let fullText = '';
                       
                        // Extract text from each page
                        for (let i = 1; i <= pdfDoc.numPages; i++) {
                            const page = await pdfDoc.getPage(i);
                            const textContent = await page.getTextContent();
                            const pageText = textContent.items.map(item => item.str).join(' ');
                            fullText += pageText + ' ';
                        }
                       
                        resolve(fullText.trim());
                    } catch (err) {
                        reject(err);
                    }
                };
               
                fileReader.onerror = reject;
                fileReader.readAsArrayBuffer(file);
            });
        }

        /**
         * Find similarities between two text documents
         */
        function findSimilarities(text1, text2, algorithm) {
            // Break texts into chunks (sentences or paragraphs)
            const chunks1 = text1.match(/[^.!?]+[.!?]+/g) || [text1];
            const chunks2 = text2.match(/[^.!?]+[.!?]+/g) || [text2];
           
            const matches = [];
           
            // Compare each chunk from text1 with each chunk from text2
            for (let i = 0; i < chunks1.length; i++) {
                const chunk1 = chunks1[i].trim();
                if (chunk1.length < 20) continue; // Skip very short chunks
               
                for (let j = 0; j < chunks2.length; j++) {
                    const chunk2 = chunks2[j].trim();
                    if (chunk2.length < 20) continue; // Skip very short chunks
                   
                    // Calculate similarity based on selected algorithm
                    let similarity;
                    switch (algorithm) {
                        case 'cosine':
                            similarity = calculateCosineSimilarity(chunk1, chunk2);
                            break;
                        case 'jaccard':
                            similarity = calculateJaccardSimilarity(chunk1, chunk2);
                            break;
                        case 'levenshtein':
                            similarity = calculateLevenshteinSimilarity(chunk1, chunk2);
                            break;
                        case 'ngram':
                            similarity = calculateNGramSimilarity(chunk1, chunk2);
                            break;
                        default:
                            similarity = calculateCosineSimilarity(chunk1, chunk2);
                    }
                   
                    // If similarity is above threshold (0.5), add to matches
                    if (similarity >= 0.5) {
                        matches.push({
                            doc1: {
                                text: chunk1,
                                index: text1.indexOf(chunk1)
                            },
                            doc2: {
                                text: chunk2,
                                index: text2.indexOf(chunk2)
                            },
                            similarity: similarity
                        });
                    }
                }
            }
           
            // Sort matches by similarity (highest first)
            matches.sort((a, b) => b.similarity - a.similarity);
           
            // Calculate overall similarity score (weighted by chunk length)
            let totalMatchedText = 0;
            matches.forEach(match => {
                totalMatchedText += match.doc1.text.length;
            });
           
            const similarityScore = Math.min(100, Math.round((totalMatchedText / text1.length) * 100));
           
            return { similarityScore, matches };
        }

        /**
         * Calculate cosine similarity between two text chunks
         */
        function calculateCosineSimilarity(text1, text2) {
            // Tokenize texts
            const tokens1 = text1.toLowerCase().split(/\W+/).filter(w => w.length > 1);
            const tokens2 = text2.toLowerCase().split(/\W+/).filter(w => w.length > 1);
           
            // Create term frequency vectors
            const allTerms = [...new Set([...tokens1, ...tokens2])];
            const vector1 = createVector(tokens1, allTerms);
            const vector2 = createVector(tokens2, allTerms);
           
            // Calculate cosine similarity
            let dotProduct = 0;
            let magnitude1 = 0;
            let magnitude2 = 0;
           
            for (let i = 0; i < allTerms.length; i++) {
                dotProduct += vector1[i] * vector2[i];
                magnitude1 += vector1[i] ** 2;
                magnitude2 += vector2[i] ** 2;





                
            }
           
            magnitude1 = Math.sqrt(magnitude1);
            magnitude2 = Math.sqrt(magnitude2);
           
            if (magnitude1 === 0 || magnitude2 === 0) return 0;
           
            return dotProduct / (magnitude1 * magnitude2);
        }

        /**
         * Create TF vector for a document
         */
        function createVector(tokens, terms) {
            const vector = new Array(terms.length).fill(0);
            const termFrequency = {};
           
            // Count term frequencies
            tokens.forEach(term => {
                termFrequency[term] = (termFrequency[term] || 0) + 1;
            });
           
            // Create vector
            terms.forEach((term, i) => {
                vector[i] = termFrequency[term] || 0;
            });
           
            return vector;
        }

        /**
         * Calculate Jaccard similarity between two text chunks
         */
        function calculateJaccardSimilarity(text1, text2) {
            // Tokenize texts
            const tokens1 = new Set(text1.toLowerCase().split(/\W+/).filter(w => w.length > 1));
            const tokens2 = new Set(text2.toLowerCase().split(/\W+/).filter(w => w.length > 1));
           
            // Calculate intersection size
            const intersection = new Set([...tokens1].filter(token => tokens2.has(token)));
           
            // Calculate union size
            const union = new Set([...tokens1, ...tokens2]);
           
            if (union.size === 0) return 0;
            return intersection.size / union.size;
        }

        /**
         * Calculate similarity based on Levenshtein distance
         */
        function calculateLevenshteinSimilarity(text1, text2) {
            // For very long texts, use a sample
            const maxLength = 1000;
            const sample1 = text1.length > maxLength ? text1.substring(0, maxLength) : text1;
            const sample2 = text2.length > maxLength ? text2.substring(0, maxLength) : text2;
           
            const distance = levenshteinDistance(sample1, sample2);
            const maxLen = Math.max(sample1.length, sample2.length);
           
            if (maxLen === 0) return 1;
            return 1 - (distance / maxLen);
        }

        /**
         * Calculate Levenshtein distance between two strings
         */
        function levenshteinDistance(s1, s2) {
            const m = s1.length;
            const n = s2.length;
           
            // Create distance matrix
            const d = [];
            for (let i = 0; i <= m; i++) {
                d[i] = [];
                d[i][0] = i;
            }
            for (let j = 0; j <= n; j++) {
                d[0][j] = j;
            }
           
            // Fill the matrix
            for (let j = 1; j <= n; j++) {
                for (let i = 1; i <= m; i++) {
                    if (s1[i-1] === s2[j-1]) {
                        d[i][j] = d[i-1][j-1];
                    } else {
                        d[i][j] = Math.min(
                            d[i-1][j] + 1,     // deletion
                            d[i][j-1] + 1,     // insertion
                            d[i-1][j-1] + 1    // substitution
                        );
                    }
                }
            }
           
            return d[m][n];
        }

        /**
         * Calculate N-gram similarity between two text chunks
         */
        function calculateNGramSimilarity(text1, text2) {
            const n = 3; 
            // Generate n-grams for both texts
            const ngrams1 = generateNGrams(text1.toLowerCase(), n);
            const ngrams2 = generateNGrams(text2.toLowerCase(), n);
           
            // Calculate intersection size
            const intersection = new Set([...ngrams1].filter(ngram => ngrams2.has(ngram)));
           
            // Calculate union size
            const union = new Set([...ngrams1, ...ngrams2]);
           
            if (union.size === 0) return 0;
            return intersection.size / union.size;
        }

        /**
         * Generate n-grams from text
         */
        function generateNGrams(text, n) {
            const ngrams = new Set();
            for (let i = 0; i <= text.length - n; i++) {
                ngrams.add(text.substring(i, i + n));
            }
            return ngrams;
        }

        /**
         * Populate document view with highlighted text
         */
        function populateDocumentView(elementId, text, matches, docIndex) {
            const docElement = document.getElementById(elementId);
            if (!docElement) return;
           
            // Create a copy of the text
            let highlightedText = text;
            let highlightPositions = [];
           
            // Collect all positions for matches in this document
            matches.forEach((match, matchIndex) => {
                const matchData = docIndex === 0 ? match.doc1 : match.doc2;
                if (matchData && matchData.index >= 0) {
                    highlightPositions.push({
                        start: matchData.index,
                        end: matchData.index + matchData.text.length,
                        matchIndex: matchIndex
                    });
                }
            });
           
            // Sort positions from end to start to avoid position shifts when inserting highlight tags
            highlightPositions.sort((a, b) => b.start - a.start);
           
            // Insert highlight tags
            highlightPositions.forEach(pos => {
                const similarity = matches[pos.matchIndex].similarity;
                let colorClass = 'success';
                if (similarity > 0.8) colorClass = 'danger';
                else if (similarity > 0.6) colorClass = 'warning';
               
                const before = highlightedText.substring(0, pos.start);
                const highlighted = highlightedText.substring(pos.start, pos.end);
                const after = highlightedText.substring(pos.end);
               
                highlightedText = `${before}<span class="highlight highlight-${colorClass}" data-match-index="${pos.matchIndex}">${highlighted}</span>${after}`;
            });
           
            // Replace newlines with <br> tags
            highlightedText = highlightedText.replace(/\n/g, '<br>');
           
            // Set the highlighted text
            docElement.innerHTML = highlightedText;
           
            // Add click handlers to highlights
            document.querySelectorAll(`#${elementId} .highlight`).forEach(highlight => {
                highlight.addEventListener('click', function() {
                    const matchIndex = parseInt(this.getAttribute('data-match-index'));
                    selectMatch(matchIndex);
                });
            });
        }

        /**
         * Populate the matches list
         */
        function populateMatchesList(elementId, matches, documentTexts) {
            const listElement = document.getElementById(elementId);
            if (!listElement) return;
           
            if (matches.length === 0) {
                listElement.innerHTML = '<p>No significant matches found.</p>';
                return;
            }
           
            let listHTML = '';
           
            matches.forEach((match, index) => {
                const similarityPercent = Math.round(match.similarity * 100);
                let colorClass = 'success';
                if (similarityPercent > 80) colorClass = 'danger';
                else if (similarityPercent > 60) colorClass = 'warning';
               
                listHTML += `
                    <div class="match-item" id="match-item-${index}" data-match-index="${index}">
                        <div class="match-header">
                            <span class="badge badge-${colorClass}">${similarityPercent}% Similar</span>
                            <span class="match-index">Match ${index + 1} of ${matches.length}</span>
                        </div>
                        <div class="match-content">
                            <div class="match-doc">
                                <strong>Document 1:</strong>
                                <div class="match-text">${match.doc1.text}</div>
                            </div>
                            <div class="match-doc">
                                <strong>Document 2:</strong>
                                <div class="match-text">${match.doc2.text}</div>
                            </div>
                        </div>
                    </div>
                `;
            });
           
            listElement.innerHTML = listHTML;
           
            // Add click handlers to match items
            document.querySelectorAll('.match-item').forEach(item => {
                item.addEventListener('click', function() {
                    const matchIndex = parseInt(this.getAttribute('data-match-index'));
                    selectMatch(matchIndex);
                });
            });
        }

        /**
         * Setup match navigation
         */
        function setupMatchNavigation(matches) {
            const prevButton = document.getElementById('prev-match');
            const nextButton = document.getElementById('next-match');
            const counter = document.getElementById('match-counter');
           
            if (!prevButton || !nextButton || !counter || matches.length === 0) return;
           
            let currentMatchIndex = -1;
           
            prevButton.addEventListener('click', () => {
                if (currentMatchIndex > 0) {
                    selectMatch(currentMatchIndex - 1);
                }
            });
           
            nextButton.addEventListener('click', () => {
                if (currentMatchIndex < matches.length - 1) {
                    selectMatch(currentMatchIndex + 1);
                } else {
                    selectMatch(0); // Loop to first match
                }
            });
           
            // Select first match initially
            if (matches.length > 0) {
                selectMatch(0);
            }
           
            // Make the selectMatch function global so it can be called from click handlers
            window.selectMatch = function(index) {
                if (index < 0 || index >= matches.length) return;
               
                // Update current index
                currentMatchIndex = index;
               
                // Update buttons
                prevButton.disabled = currentMatchIndex <= 0;
                nextButton.disabled = currentMatchIndex >= matches.length - 1;
               
                // Update counter
                counter.textContent = `Match ${currentMatchIndex + 1} of ${matches.length}`;
               
                // Scroll to match in documents
                document.querySelectorAll('.highlight').forEach(el => {
                    el.classList.remove('highlight-active');
                });
               
                document.querySelectorAll(`.highlight[data-match-index="${index}"]`).forEach(el => {
                    el.classList.add('highlight-active');
                    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                });
               
                // Scroll to match in list
                document.querySelectorAll('.match-item').forEach(el => {
                    el.classList.remove('match-item-active');
                });
               
                const matchItem = document.getElementById(`match-item-${index}`);
                if (matchItem) {
                    matchItem.classList.add('match-item-active');
                    matchItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            };
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize PDF uploader
            initPDFUploader();
           
            // Load Google API
            loadGoogleAPI();
           
            // Set up event listeners for the Google Classroom tab
            document.getElementById('google-signin-btn').addEventListener('click', handleAuthClick);
            document.getElementById('logout-btn').addEventListener('click', handleSignoutClick);
            document.getElementById('select-course-btn').addEventListener('click', function() {
                if (selectedCourseId) {
                    listAssignments(selectedCourseId);
                }
            });
           
            // Set up advanced settings panel toggle
            document.getElementById('settings-toggle').addEventListener('click', function() {
                const settingsContent = document.getElementById('settings-content');
                settingsContent.style.display = settingsContent.style.display === 'none' ? 'block' : 'none';
            });
        });
    </script>
</body>
</html>